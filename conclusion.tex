\section{Conclusion} \label{sec:conclusion}

%
We began by surveying ``serendipity'', developing a broad historical
view, and describing several criteria for serendipity which we propose
to be computationally salient.  We reviewed related work; like
\citeA{andre2009discovery}, we propose a two-part definition of
serendipity: \emph{discovery} followed by \emph{invention}.
%
Adapting the ``Standardised Procedure for Evaluating Creative
Systems'' (SPECS) model from \citeA{jordanous:12}, we developed a set
of evaluation standards for serendipity.
%
We used this model to analyse prior examples of serendipity in the
context of evolutionary music improvisation and recommender systems,
and developed a thought experiment that seems able to support ``high
serendipity'' with a novel design for a computational poetry workshop.
%
We then reflected back over our definition, outlining a programme for
serendipitous computing in the pursuit of \emph{autonomy},
\emph{learning}, \emph{sociality}, and \emph{embedded evaluation}.  We
posit the following challenges, which connect with ongoing discussions
in the field:
%
\begin{itemize}
\item \emph{A primary challenge to the serendipitous operation of
  computers is developing computational agents that specify their own
  problems.}
\item \emph{A second challenge is for computational agents to learn
  more and more about the world we live in.}
\item \emph{A third challenge is for computational agents to interact
  in a recognisably social way with us and with each other, resulting
  in emergent effects.}
\item \emph{A fourth challenge is for computational agents to evaluate
  their own creative process and products.}
\end{itemize}
%
In the current work, we have limited ourselves to clarifying
conceptual issues surrounding our definition of serendipty, and
examining their design implications.
% 
We indicate several possible further directions for implementation
work in each of our case studies.  We have also drawn attention to
theoretical questions related program design in an autonomous
programming context.  Our examples show that serendipity is not
foreign to computing practice.  There are further gains to be had for
research in computing by planning -- and programming -- for
serendipity.
%

